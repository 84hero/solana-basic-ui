# 管理分叉

账本允许在插槽边界处发生分叉。由此形成的数据结构构成了一个称为*块存储*的树。当验证器解释块存储时，它必须为链中的每个分支维持状态。验证器有责任权衡这些分叉，以便它能最终选择一个分叉。有关这些分叉的选择和投票的详细信息，请参见 [Tower Bft](https://docs.solanalabs.com/implemented-proposals/tower-bft)。



## 分叉

分叉是从某个根开始的一系列插槽。例如：

```markdown
 0 - 1       12 - 13
      \     /
       3 - 5
     ROOT   \
             7 - 9 - 10 - 11
```

以下是分叉的一些实例：

```markdown
- {0, 1, 2, 4, 6, 8}
- {0, 1, 3, 5, 12, 13}
- {0, 1, 3, 5, 7, 9, 10, 11}
```



## 修剪和压缩

随着链的增长，存储本地分叉视图会对性能产生不利影响。幸运的是，我们可以利用Tower BFT根的属性来修剪这个数据结构。回想一下，根是已经达到最大锁定深度的插槽。假设这个插槽已经积累了足够的锁定，以至于不可能回滚这个插槽。

因此，验证器会修剪那些不是起源于其本地的分叉，并且借此机会压缩所有可以压缩到根节点的节点来最小化内存使用。虽然这对于共识不是必须得，但是为了支持某些RPC用例，验证器会选择保留其本地根的祖先节点，直到绝大多数的集群确认最后一个插槽。我们称之为超级多数根（SMR）。

从上诉例子开始，假设最大锁定深度为3。我们的验证器在`0，1，3，5，7，9`。在对`9`进行最终投票后，我们的本地根节点变为3.假设最新的超级多数根是`0`。修剪后，我们的本地分叉视图如下：

```markdown
SMR
 0 - 1       12 - 13
      \     /
       3 - 5
     ROOT   \
             7 - 9 - 10 - 11
```

现在假设我们对`10`进行投票，并且`5`成为根。与此同时，集群赶上了进度，最新的超级多数根现在是`3`。修剪后，我们的本地分支视图如此：

```markdown
             12 - 13
            /
       3 - 5 ROOT
      SMR   \
             7 - 9 - 10 - 11
```

最后，对`11`进行投票，`7`成为根，从而修剪掉最后一个分叉：

```markdown
       3 - 5 - 7 - 9 - 10 - 11
      SMR     ROOT
```

